## 문제점
> 동시에 여러개의 요청이 들어온다면?

병렬로 동시에 1000개의 쿠폰 발급 요청을 보낸다면 ApplyService의 쿠폰 생성 개수를 100개로 재한하는 로직
때문에 100개의 쿠폰만 생성된 상태여야 한다.

하지만 테스트 결과 100개가 아닌 그보다 많은 수의 쿠폰이 발급된 것을 확인할 수 있었다.

이는 두개 이상의 스레드가 공유 데이터에 접근하고 임계영역을 변경하고자 하는 `Race Condition`이 발생했기 때문이다.

총 쿠폰의 수가 99개일때 스레드1이 쿠폰 개수를 읽어가고(99개) 쿠폰을 생성하기 이전에
스레드2가 쿠폰 개수를 읽어 간다면(99개) 스레드2가 쿠폰을 생성하게 되면서 총 쿠폰이 101개가 되고만다.

## 해결 방안
Race condition을 해결하기 위해서 @Synchronized 키워드를 사용할 수 있지만 서버가 여러대인 경우라면
해결책이 되지 못한다.

MySQL, Redis의 락을 활용하여 Race Condition을 해결할 수도 있다.
하지만 여기서 원하는건 쿠폰 개수에 대한 정합성이다. 만약 락을 사용하게 된다면
발급된 총 쿠폰 개수를 가져오는 로직부터 쿠폰을 생성하는 로직까지의 흐름은 전부 락을 걸어야한다.
결국 락을 거는 구간이 길어지기 때문에 성능에 문제가 발생할 수 있다.
예를 들어 쿠폰을 저장하는 로직이 2초가 소요된다면 락이 해제되는데는 2초 이상이 걸리게 되고 그만큼 다른 사용자들은 기다려야한다.

핵심은 쿠폰 개수에 대한 정합성만 관리하면 된다.

레디스의 incr 명령어를 사용하여 발급된 쿠폰 개수를 제어하여 해결한다.
레디스는 싱글 스레드로 동작하기 때문에 Race Condition을 해결할 수 있다.
`incr` 명령어는 왜 성능이 빠를까?

하지만 레디스를 사용하는 방법의 경우에도 발급할 쿠폰의 수가 많아질수록 RDB에 많은 부하를 준다.
